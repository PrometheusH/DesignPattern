# Facade  
外观模式  
核心思想：中介  
让专业的人干专业的事情  
实际场景：公司有很多小的已经写好的工具，而我这个客户端只需要其中的几个工具做成一个功能。
## 定义
>为子系统中的接口提供一个一致的`界面（外观）`

界面（外观）：从这系统的外部来看这个系统能看到什么，从一个类的外部看这个类，所有的public方法就是这个类的外观
客户端和被访问系统之间的通道/中介
可以是普通类，可以是接口类


## 代码介绍
### old
#### 特点：
>Client直接通过Business、DAO、Presentation类来调用其中的方法
#### 简介：
- ConfigManager是一个单例用来通过配置文件生成ConfigModel
- ConfigModel是Presentation表现层，Business逻辑层，DAO数据层的一个模型，存储着通过当前配置文件生成的三个类
- Presentation、Business、DAO类通过ConfigModel拿到通过配置文件生成的自己类的实例
- Client直接与Presentation、Business、DAO类交互使用里面的方法。
#### 存在问题：
- 客户端必须对这个系统中的`所有类的所有方法/接口`都要有所了解，才知道该使用哪个，即使是那些内部之间互相调用的方法不去看也不知道。这就是接口污染。
- 当这些类的调用顺序发生改变时，需`更改所有客户端`中的代码

### model
- AmoduleApi、BmoduleApi、CmoduleApi都是一个外部系统，提供的一些接口，用来处理一些数据。该系统还有其他接口，但当前Client只需要这三个接口中的指定方法
- 通过外观类Facade将这些方法封装了起来，Client只知道要实现当前功能只需要调用Facade中的那一个方法即可

### concrete
- 将old中Client中的调用，放到一个新类Facade中即可

## 优劣分析
### 优点：
- 对于客户端
  - 不需要了解全部的外部系统中的方法，直接使用Facade类就能实现相应的功能，减少了学习成本，开发成本。符合接口隔离原则ISP和最少知识原则LKP（不用去了解不需要知道接口）。
- 对于外部系统
  - 很好地划分了访问层次，需要暴露的接口，客户端可以通过外观类使用，不需要暴露的接口，客户端看不到。
  -  Facade类可以被多个客户端复用，当外部系统的类方法调用顺序或调用方式改变时，变化被外观类吸收和消化，不用修改客户端，
  只需修改Facade类即可，系统更有弹性。换句话说在不影响客户端的情况下，实现了系统内部的维护和扩展。符合开放-关闭原则OCP。
### 缺点：
过多或不合理的Facade让人疑惑，不知道是直接调用现有的Facade好呢，还是再写一个Facade还是直接调用外部类中的方法。
## 注意（不要做）
Facade的目的是减少外部系统与客户端之间的耦合，组合`已有的功能`来实现客户端的需要，不是为了给外部系统添加新的功能接口，所以不要在Facade中定义外部系统没有的功能。

## 更多
- 将Facade类中的方法实现成静态的，这样就不需要创建外观实例而直接调用，成了一个辅助工具类
```java
/**
 * 外观对象
 */
public class Facade {
    private Facade(){}
    public static void test(){
        AModuleApi a = new AModuleImpl();
        a.testA();
        BModuleApi b = new BModuleImpl();
        b.testB();
        CModuleApi c = new CModuleImpl();
        c.testC();
    }
}
```
- 也可以将Facade写成接口，不过这样需要增加相应的工厂类，增加了复杂度。

## 不明白的问题：（要如实记录，要透明）
客户端也可以直接使用外部类中的方法，怎么说防止了接口污染呢？也能看到啊。

## 与其他模式的辨析
### 与中介者模式的区别
在中介者模式中有记

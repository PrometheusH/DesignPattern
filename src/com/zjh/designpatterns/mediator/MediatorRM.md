# Mediator 中介者模式

问题：系统中各个模块之间需要交互，只能笛卡尔积地交互，每一个分别与其他模块进行交互，而且，如果一个模块发生了改变，那就要改动所有的模块。


## old
无，直接进入模型

## model
交互的对象称为同事类  
中介者对象用来维护各个同事之间的关系
- Collegue：同事抽象类，通常实现为抽象类。  
作用：  
1.约束所有同事类的类型  
2.定义所有同事类的共有部分：如所有的同事类都需要知道中介者==持有中介者对象

- ConcreteColleagueA 具体的同事类，继承抽象的同事类

- Mediator：中介者，通常为接口类型  
作用：  
1.定义各个同事对象通信的接口

- ConcreteMediator 具体的中介者，实现了中介者接口  
作用：  
1.具体维护同事类之间的关系==持有所有的同事类对象

## concrete

- MotherBoard类：主板，实现中介者接口  
作用：负责CPU、光驱、声卡、显卡之间的交互
持有所有的colleague对象，当一个colleage对象的状态数据更新时，
会调用它的change方法，里面会判断是谁调用的，给出相应的处理方式。
- CPU类：CPU，继承同事类抽象方法  
作用解析CDDriver读入的数据
- CDDriver类：光驱，继承同事类抽象方法  
作用：负责从光盘读出数据
- SoundCard类：声卡，继承同事类抽象方法   
作用：播放CPU解析出来的声音数据
- VideoCard类：显卡，继承同事类抽象方法   
作用：播放CPU解析出来的额视频数据


## 使用场景
如果一个对象的变化想引起其他对象的变化，而这个对象又不想自己处理这些关系。当我的对象状态发生改变的时候，
只调用中介者的方法，就可以将我的状态更新给想要知道的对象。

## 优缺点
- 优点：  
  - 解耦：集中控制这些交互关系，修改起来方便。
- 缺点： 

- 特点：   
  - 中介者和同事类们相互依赖，同事类需要知道中介者是谁，中介者也需要知道所有的同事类 
  - 同事之间的关系：它们之间要相互通信，都知道同一个中介者。

## 注意
- 同事类们和中介者之间的通信方式有两种：  
  1.直接在Mediator接口中定一个change方法。  
  2.采用观察者模式，把Media实现成Observer，各个同事类实现成Subject  

## 不明白的地方
这是顺序执行下的模式，并发下怎么保证呢？
一个同事说我更新了，另一个同事说我也更新了，但是他的更新要依赖另一个的更新，这不就乱套了。

## 问题与解决：
- Mediator接口存在的必要是什么？   
接口是用来封装隔离的，封装中介者对象，使中介者对象和它管理的同事类隔离。  
如果预计中介者只有一个，且没有扩展的需求，可以直接使用中介者对象，反之，要求各个Colleague对象面向中介者接口编程，而无需关心具体的中介者实现。


## 模式辨析
- 与外观模式  
Facade和ConcreteMediator都持有需要操作的类，都没有增加新功能，Facade是调用方法处理数据，ConcreteMediator是通知各个类（调用相应的方法）。
Facade很简单，只是简单的隔离调用，是单向的。Mediator还需要对方持有自己的对象，调用相应的方法，是双向的。
- 与观察者模式  
因为双方状态变化要互相通知，所以可以使用观察者模式。
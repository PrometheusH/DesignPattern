# Mediator 中介者模式

问题：系统中各个模块之间需要交互，只能笛卡尔积地交互，每一个分别与其他模块进行交互，而且，如果一个模块发生了改变，那就要改动所有的模块。


## old
无，直接进入模型

## model
同事类：相互之间进行交互的对象称为同事类  
- Collegue：同事抽象类，通常实现为抽象类。  
作用：  
1.约束所有同事类的类型  
2.定义所有同事类的共有部分：如所有的同事类都需要知道中介者==持有中介者对象

- ConcreteColleagueA 具体的同事类，继承抽象的同事类

- Mediator：中介者，通常为接口类型  
作用：  
1.定义各个同事对象通信的接口

- ConcreteMediator 具体的中介者，实现了中介者接口  
作用：  
1.具体维护同事类之间的关系==持有所有的同事类对象

## concrete

- MotherBoard类：主板，实现中介者接口  
作用：负责CPU、光驱、声卡、显卡之间的交互
持有所有的colleague对象，当一个colleage对象的状态数据更新时，
会调用它的change方法，里面会判断是谁调用的，给出相应的处理方式。

- CPU类：CPU，继承同事类抽象方法  
作用解析CDDriver读入的数据

- CDDriver类：光驱，继承同事类抽象方法  
作用：负责从光盘读出数据

- SoundCard类：声卡，继承同事类抽象方法   
作用：播放CPU解析出来的声音数据

- VideoCard类：显卡，继承同事类抽象方法   
作用：播放CPU解析出来的额视频数据

## advanced
狭义中介者特点：   
  - 中介者和同事类们相互依赖，同事类需要知道中介者是谁，中介者也需要知道所有的同事类 
  - 同事之间的关系：它们之间要相互通信，都知道同一个中介者。
广义中介者——简化的中介者模式
为什么要简化中介者模式？P232中介者和同事类之间的依赖关系太强了。
实例：部门和人员之间的关系是多对多的关系，用标准的中介者模式太别扭了，每个同事都要持有其他同事的集合

简化：   
1.去掉同事对象的父类，这样只要与这些同事类进行交流，随时可以成为同事类。   
2.不定义Mediator接口，将中介者对象实现为单例   
3.同事对象不再持有中介者对象，需要时，直接获取中介者对象调用其中方法     
中介者对象也不再持有同事对象，而是在具体处理方法里面去创建，或者通过参数传入   

需求：
1.部门被撤销
2.部门之间进行合并
3.人员离职
4.人员从一个部门调到另一个部门

- Dep类：部门类
方法deleteDep是删除部门，因为要先把用户移出该部门才能删除，跟其他同事类发生了联系，所以需要部分逻辑在中介者类中处理

- User类：员工类
方法deleteUser，员工离职，需要先将员工从所在部门移除，再设置离职标志，所以，也与同事类发生联系，这部门逻辑也需要在中介者类中实现
- DepUserMediatorImpl：简化的中介者类，单例实现
负责处理部门与员工之间的逻辑，部门与部门之间的逻辑，员工与员工之间的逻辑



## 使用场景
如果一个对象的变化想引起其他对象的变化，而这个对象又不想自己处理这些关系。当我的对象状态发生改变的时候，
只调用中介者的方法，就可以将我的状态更新给想要知道的对象。

## 优缺点
- 优点：  
  - 解耦：同事对象之间耦合松散
  - 集中控制这些交互关系，修改起来方便
  - 同事对象之间的多对多变为中介者对象和同事对象之间的一对多==一个中介者对象持有多个同事对象，使得对象关系容易理解和实现
- 缺点： 
  - Java是单继承的，让这些同事类都继承同一个父类是否合适————通过广义的中介者模式解决
  - 过度集中化，如果同事对象太多，交互复杂，这些全部集中到中介者会导致中介者难以管理和维护

## 注意
- 同事类们和中介者之间的通信方式有两种：  
  1.直接在Mediator接口中定一个change方法。  
  2.采用观察者模式，把Media实现成Observer，各个同事类实现成Subject  

## 不明白的地方
这是顺序执行下的模式，并发下怎么保证呢？
一个同事对象说我更新了，另一个同事说我也更新了，但是他的更新要依赖另一个的更新，这不就乱套了。

## 问题与解决：
- Mediator接口存在的必要是什么？   
接口是用来封装隔离的，封装中介者对象，使中介者对象和它管理的同事类隔离。  
如果预计中介者只有一个，且没有扩展的需求，可以直接使用中介者对象，反之，要求各个Colleague对象面向中介者接口编程，而无需关心具体的中介者实现。


## 模式辨析
- 与外观模式  
  - Facade和ConcreteMediator都持有需要操作的类，都没有增加新功能，Facade是调用方法处理数据，ConcreteMediator是通知各个类（调用相应的方法）。   
  - Facade很简单，只是简单的隔离调用，是单向的。Mediator还需要对方持有自己的对象，调用相应的方法，是双向的。   
  - Favade关注的是外部系统的方法。Mediator关注的是同事类之间类变量的状态变化。
- 与观察者模式  
因为双方状态变化要互相通知，所以可以使用观察者模式。